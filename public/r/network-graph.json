{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "network-graph",
  "title": "Network Graph",
  "description": "A force-directed network graph component. Supports pan, zoom, drag, node selection, search, minimap, export, tree/radial layouts, and automatic theming via shadcn CSS variables.",
  "dependencies": [
    "lucide-react"
  ],
  "registryDependencies": [
    "button"
  ],
  "files": [
    {
      "path": "registry/ui/network-graph.tsx",
      "content": "\"use client\"\n\n/**\n * network-graph.tsx\n * Place at: components/ui/network-graph.tsx\n *\n * A shadcn-compatible force-directed network graph component.\n *\n * Conventions followed (identical to first-party shadcn components):\n *  - cn() for all class composition, zero injected stylesheets\n *  - className forwarded on every sub-component\n *  - data-slot on every element\n *  - Plain function components (React 19 ref-as-prop)\n *  - TypeScript interfaces extending the correct HTML/SVG element types\n *  - Tailwind semantic classes only (fill-card, stroke-border, etc.)\n *  - Uses shadcn <Button> and lucide-react icons\n *  - Named + default exports\n *\n * Dependencies (already in any shadcn project):\n *   lucide-react, @/lib/utils (cn), @/components/ui/button\n */\n\nimport * as React from \"react\"\nimport { Maximize2, ZoomIn, ZoomOut, Download, ImageDown } from \"lucide-react\"\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\nimport {\n  runSimulation,\n  getNodeExitPoint,\n  getEdgeKey,\n  type SimNode,\n  type SimulationConfig,\n} from \"@/components/ui/network-graph-simulation\"\nimport {\n  computeTreeLayout,\n  computeRadialLayout,\n} from \"@/components/ui/network-graph-layouts\"\n\n// ─── Public types ──────────────────────────────────────────────────────────────\n\nexport interface NetworkGraphNode {\n  id: string\n  label: string\n  subtitle?: string\n  /** Emoji or short string rendered in the icon slot */\n  icon?: string\n  /** Initial x position. If omitted, randomized by simulation. */\n  x?: number\n  /** Initial y position. If omitted, randomized by simulation. */\n  y?: number\n  /** When true, simulation will not move this node. Default: false */\n  fixed?: boolean\n  /** Semantic color preset for the node card. Default: \"default\" */\n  color?: \"default\" | \"primary\" | \"secondary\" | \"destructive\" | \"accent\"\n  /** Group identifier — nodes with the same group are visually clustered */\n  group?: string\n}\n\nexport interface NetworkGraphEdge {\n  source: string\n  target: string\n  /** Optional label displayed at the edge midpoint */\n  label?: string\n  /** When true, shows a marching-ants animation on the edge */\n  animated?: boolean\n}\n\n// ─── Internal constants ────────────────────────────────────────────────────────\n\nconst NODE_W = 148\nconst NODE_H = 46\nconst ICON_W = 28\nconst ICON_PAD = 10\nconst LABEL_X = ICON_PAD + ICON_W + 8\n/** Arrow marker size — used to offset edge endpoint so line doesn't overlap arrowhead */\nconst ARROW_OFFSET = 6\n\n// ─── Node color presets ───────────────────────────────────────────────────────\n\nconst NODE_COLOR_CLASSES: Record<\n  NonNullable<NetworkGraphNode[\"color\"]>,\n  { rect: string; iconBg: string; label: string; subtitle: string }\n> = {\n  default:     { rect: \"fill-card stroke-border\",              iconBg: \"fill-muted\",           label: \"fill-card-foreground\",      subtitle: \"fill-muted-foreground\" },\n  primary:     { rect: \"fill-primary stroke-primary\",          iconBg: \"fill-primary/20\",      label: \"fill-primary-foreground\",   subtitle: \"fill-primary-foreground/70\" },\n  secondary:   { rect: \"fill-secondary stroke-border\",         iconBg: \"fill-secondary/50\",    label: \"fill-secondary-foreground\", subtitle: \"fill-secondary-foreground/70\" },\n  destructive: { rect: \"fill-destructive stroke-destructive\",  iconBg: \"fill-destructive/20\",  label: \"fill-destructive-foreground\", subtitle: \"fill-destructive-foreground/70\" },\n  accent:      { rect: \"fill-accent stroke-accent\",            iconBg: \"fill-accent/50\",       label: \"fill-accent-foreground\",    subtitle: \"fill-accent-foreground/70\" },\n}\n\n// ─── NetworkGraphNodeCard ──────────────────────────────────────────────────────\n\nexport interface NetworkGraphNodeCardProps\n  extends React.ComponentProps<\"g\"> {\n  node: NetworkGraphNode\n  position: { x: number; y: number }\n  selected?: boolean\n  interactive?: boolean\n  onNodePointerDown?: (e: React.PointerEvent<SVGGElement>, id: string) => void\n  onNodeSelect?: (id: string) => void\n}\n\nfunction NetworkGraphNodeCard({\n  node,\n  position,\n  selected = false,\n  interactive = true,\n  onNodePointerDown,\n  onNodeSelect,\n  className,\n  style,\n  ...props\n}: NetworkGraphNodeCardProps) {\n    const x = position.x - NODE_W / 2\n    const y = position.y - NODE_H / 2\n    const hasSub = Boolean(node.subtitle)\n    const cc = NODE_COLOR_CLASSES[node.color ?? \"default\"]\n\n    return (\n      <g\n        data-slot=\"network-graph-node\"\n        data-selected={selected || undefined}\n        data-interactive={interactive || undefined}\n        className={cn(\n          interactive && \"cursor-grab active:cursor-grabbing\",\n          className\n        )}\n        transform={`translate(${x},${y})`}\n        onPointerDown={\n          interactive\n            ? (e) => {\n                e.stopPropagation()\n                onNodePointerDown?.(e, node.id)\n              }\n            : undefined\n        }\n        onClick={\n          interactive\n            ? (e) => {\n                e.stopPropagation()\n                onNodeSelect?.(node.id)\n              }\n            : undefined\n        }\n        role={interactive ? \"button\" : undefined}\n        aria-label={node.label}\n        aria-pressed={interactive ? selected : undefined}\n        tabIndex={interactive ? 0 : undefined}\n        onKeyDown={\n          interactive\n            ? (e) => e.key === \"Enter\" && onNodeSelect?.(node.id)\n            : undefined\n        }\n        // drop-shadow equivalent of shadcn Card's shadow-sm for SVG elements\n        // (Tailwind shadow-* utilities don't apply to SVG <g>)\n        style={{\n          filter: `drop-shadow(0 1px 2px hsl(var(--foreground) / 0.06))`,\n          transition: \"filter 150ms ease\",\n          ...style,\n        }}\n        {...props}\n      >\n        {/* Card background — matches shadcn <Card> shell exactly */}\n        <rect\n          data-slot=\"network-graph-node-rect\"\n          width={NODE_W}\n          height={NODE_H}\n          rx={6}\n          className={cn(\n            cc.rect,\n            \"[stroke-width:1]\",\n            \"transition-[stroke,stroke-width] duration-150\",\n            selected && \"stroke-ring [stroke-width:2]\"\n          )}\n        />\n\n        {/* Icon background — bg-muted */}\n        <rect\n          data-slot=\"network-graph-node-icon-bg\"\n          x={ICON_PAD}\n          y={(NODE_H - ICON_W) / 2}\n          width={ICON_W}\n          height={ICON_W}\n          rx={4}\n          className={cc.iconBg}\n        />\n\n        {/* Icon */}\n        <text\n          data-slot=\"network-graph-node-icon\"\n          x={ICON_PAD + ICON_W / 2}\n          y={NODE_H / 2}\n          textAnchor=\"middle\"\n          dominantBaseline=\"middle\"\n          fontSize={14}\n          className=\"pointer-events-none select-none\"\n        >\n          {node.icon ?? \"◈\"}\n        </text>\n\n        {/* Label — text-[12px] font-medium fill-card-foreground */}\n        <text\n          data-slot=\"network-graph-node-label\"\n          x={LABEL_X}\n          y={NODE_H / 2 - (hasSub ? 7 : 0)}\n          dominantBaseline=\"middle\"\n          fontSize={12}\n          fontWeight={500}\n          className={cn(\"pointer-events-none select-none\", cc.label)}\n        >\n          {node.label}\n        </text>\n\n        {/* Subtitle — text-[10px] fill-muted-foreground */}\n        {hasSub && (\n          <text\n            data-slot=\"network-graph-node-subtitle\"\n            x={LABEL_X}\n            y={NODE_H / 2 + 8}\n            dominantBaseline=\"middle\"\n            fontSize={10}\n            className={cn(\"pointer-events-none select-none\", cc.subtitle)}\n          >\n            {node.subtitle}\n          </text>\n        )}\n      </g>\n    )\n}\n\n// ─── NetworkGraphEdgeLine ──────────────────────────────────────────────────────\n\nexport interface NetworkGraphEdgeLineProps\n  extends React.ComponentProps<\"line\"> {\n  edge: NetworkGraphEdge\n  positions: Record<string, { x: number; y: number }>\n  highlighted?: boolean\n}\n\nfunction NetworkGraphEdgeLine({ edge, positions, highlighted = false, className, ...props }: NetworkGraphEdgeLineProps) {\n  const s = positions[edge.source]\n  const t = positions[edge.target]\n  if (!s || !t) return null\n\n  // Exit source node bounding box, enter target offset by arrow marker size\n  const nodeBounds = { width: NODE_W, height: NODE_H }\n  const exit = getNodeExitPoint(s, t, nodeBounds)\n\n  // For the entry point: flip direction (target → source) to get target border exit,\n  // then offset inward by ARROW_OFFSET so arrowhead doesn't overlap the node\n  const dx = t.x - s.x\n  const dy = t.y - s.y\n  const dist = Math.sqrt(dx * dx + dy * dy) || 1\n  const ux = dx / dist\n  const uy = dy / dist\n  const entry = getNodeExitPoint(t, s, nodeBounds)\n  const x2 = entry.x + ux * ARROW_OFFSET\n  const y2 = entry.y + uy * ARROW_OFFSET\n\n  return (\n    <line\n      data-slot=\"network-graph-edge\"\n      data-highlighted={highlighted || undefined}\n      className={cn(\n        \"stroke-border transition-[stroke,stroke-width] duration-150\",\n        highlighted && \"stroke-muted-foreground\",\n        edge.animated && \"ng-animated-edge\",\n        className\n      )}\n      strokeWidth={highlighted ? 2 : 1.5}\n      x1={exit.x}\n      y1={exit.y}\n      x2={x2}\n      y2={y2}\n      markerEnd={\n        highlighted ? \"url(#ng-arrow-hi)\" : \"url(#ng-arrow)\"\n      }\n      {...props}\n    />\n  )\n}\n\n// ─── NetworkGraphEdgeLabel ─────────────────────────────────────────────────────\n\nexport interface NetworkGraphEdgeLabelProps\n  extends React.ComponentProps<\"g\"> {\n  label: string\n  x: number\n  y: number\n  highlighted?: boolean\n}\n\nfunction NetworkGraphEdgeLabel({ label, x, y, highlighted = false, className, ...props }: NetworkGraphEdgeLabelProps) {\n  // Heuristic sizing: ~6px per char at 10px font, 8px horizontal padding, 16px height\n  const textW = label.length * 6\n  const padX = 4\n  const padY = 2\n  const rw = textW + padX * 2\n  const rh = 14 + padY * 2\n\n  return (\n    <g\n      data-slot=\"network-graph-edge-label\"\n      className={cn(\"pointer-events-none\", className)}\n      transform={`translate(${x - rw / 2},${y - rh / 2})`}\n      {...props}\n    >\n      <rect\n        width={rw}\n        height={rh}\n        rx={4}\n        className={cn(\n          \"fill-card stroke-border [stroke-width:0.5]\",\n          highlighted && \"stroke-muted-foreground\"\n        )}\n      />\n      <text\n        x={rw / 2}\n        y={rh / 2}\n        textAnchor=\"middle\"\n        dominantBaseline=\"middle\"\n        fontSize={10}\n        className={cn(\n          \"select-none fill-muted-foreground\",\n          highlighted && \"fill-foreground\"\n        )}\n      >\n        {label}\n      </text>\n    </g>\n  )\n}\n\n// ─── Convex hull utilities ────────────────────────────────────────────────────\n\nfunction cross(o: { x: number; y: number }, a: { x: number; y: number }, b: { x: number; y: number }) {\n  return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x)\n}\n\n/** Graham scan — returns hull vertices in CCW order */\nfunction convexHull(pts: { x: number; y: number }[]): { x: number; y: number }[] {\n  const sorted = [...pts].sort((a, b) => a.x - b.x || a.y - b.y)\n  if (sorted.length <= 2) return sorted\n  const lower: typeof sorted = []\n  for (const p of sorted) {\n    while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0)\n      lower.pop()\n    lower.push(p)\n  }\n  const upper: typeof sorted = []\n  for (let i = sorted.length - 1; i >= 0; i--) {\n    const p = sorted[i]\n    while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0)\n      upper.pop()\n    upper.push(p)\n  }\n  lower.pop()\n  upper.pop()\n  return lower.concat(upper)\n}\n\n/** Expand hull outward from centroid and build a rounded SVG path */\nfunction hullPath(pts: { x: number; y: number }[], pad: number): string {\n  if (pts.length === 0) return \"\"\n  const cx = pts.reduce((s, p) => s + p.x, 0) / pts.length\n  const cy = pts.reduce((s, p) => s + p.y, 0) / pts.length\n\n  if (pts.length === 1) {\n    const x = pts[0].x - NODE_W / 2 - pad\n    const y = pts[0].y - NODE_H / 2 - pad\n    const w = NODE_W + pad * 2\n    const h = NODE_H + pad * 2\n    const r = Math.min(pad, 16)\n    return `M${x + r},${y} h${w - 2 * r} a${r},${r} 0 0 1 ${r},${r} v${h - 2 * r} a${r},${r} 0 0 1 -${r},${r} h-${w - 2 * r} a${r},${r} 0 0 1 -${r},-${r} v-${h - 2 * r} a${r},${r} 0 0 1 ${r},-${r} Z`\n  }\n\n  // Expand each point outward from centroid\n  const expanded = pts.map((p) => {\n    const dx = p.x - cx\n    const dy = p.y - cy\n    const dist = Math.sqrt(dx * dx + dy * dy) || 1\n    return { x: p.x + (dx / dist) * pad, y: p.y + (dy / dist) * pad }\n  })\n\n  // Build rounded polygon path with quadratic curves at corners\n  const n = expanded.length\n  const parts: string[] = []\n  for (let i = 0; i < n; i++) {\n    const curr = expanded[i]\n    const next = expanded[(i + 1) % n]\n    const mx = (curr.x + next.x) / 2\n    const my = (curr.y + next.y) / 2\n    if (i === 0) parts.push(`M${mx},${my}`)\n    parts.push(`Q${next.x},${next.y} ${(next.x + expanded[(i + 2) % n].x) / 2},${(next.y + expanded[(i + 2) % n].y) / 2}`)\n  }\n  parts.push(\"Z\")\n  return parts.join(\" \")\n}\n\n// ─── NetworkGraphGroup ────────────────────────────────────────────────────────\n\nexport interface NetworkGraphGroupProps\n  extends React.ComponentProps<\"g\"> {\n  groupId: string\n  nodes: NetworkGraphNode[]\n  positions: Record<string, { x: number; y: number }>\n}\n\nfunction NetworkGraphGroup({ groupId, nodes, positions, className, ...props }: NetworkGraphGroupProps) {\n  const pts = nodes\n    .filter((n) => positions[n.id])\n    .map((n) => positions[n.id])\n  if (pts.length === 0) return null\n\n  const hull = pts.length >= 3 ? convexHull(pts) : pts\n  const pathD = hullPath(hull, 32)\n  const cx = pts.reduce((s, p) => s + p.x, 0) / pts.length\n  const cy = Math.min(...pts.map((p) => p.y)) - NODE_H / 2 - 24\n\n  return (\n    <g\n      data-slot=\"network-graph-group\"\n      className={cn(\"pointer-events-none\", className)}\n      {...props}\n    >\n      <path\n        d={pathD}\n        className=\"fill-muted/30 stroke-border [stroke-width:1.5] [stroke-dasharray:4_3]\"\n      />\n      <text\n        x={cx}\n        y={cy}\n        textAnchor=\"middle\"\n        dominantBaseline=\"middle\"\n        fontSize={11}\n        fontWeight={500}\n        className=\"select-none fill-muted-foreground\"\n      >\n        {groupId}\n      </text>\n    </g>\n  )\n}\n\n// ─── NetworkGraphControls ──────────────────────────────────────────────────────\n// Uses actual shadcn <Button variant=\"outline\" size=\"icon\"> — no custom classes\n\nexport interface NetworkGraphControlsProps\n  extends React.ComponentProps<\"div\"> {\n  onZoomIn?: () => void\n  onZoomOut?: () => void\n  onFit?: () => void\n  onExportSVG?: () => void\n  onExportPNG?: () => void\n}\n\nfunction NetworkGraphControls({ onZoomIn, onZoomOut, onFit, onExportSVG, onExportPNG, className, ...props }: NetworkGraphControlsProps) {\n  return (\n    <div\n      data-slot=\"network-graph-controls\"\n      className={cn(\"absolute bottom-3 right-3 flex flex-col gap-1\", className)}\n      {...props}\n    >\n      <Button variant=\"outline\" size=\"icon\" className=\"size-7\" onClick={onZoomIn} aria-label=\"Zoom in\">\n        <ZoomIn />\n      </Button>\n      <Button variant=\"outline\" size=\"icon\" className=\"size-7\" onClick={onZoomOut} aria-label=\"Zoom out\">\n        <ZoomOut />\n      </Button>\n      <Button variant=\"outline\" size=\"icon\" className=\"size-7\" onClick={onFit} aria-label=\"Reset view\">\n        <Maximize2 />\n      </Button>\n      {onExportSVG && (\n        <Button variant=\"outline\" size=\"icon\" className=\"size-7\" onClick={onExportSVG} aria-label=\"Export SVG\">\n          <Download />\n        </Button>\n      )}\n      {onExportPNG && (\n        <Button variant=\"outline\" size=\"icon\" className=\"size-7\" onClick={onExportPNG} aria-label=\"Export PNG\">\n          <ImageDown />\n        </Button>\n      )}\n    </div>\n  )\n}\n\n// ─── NetworkGraphNodeInfo ──────────────────────────────────────────────────────\n// Bottom-center status bar shown when a node is selected.\n// Styled like shadcn's inline badge/popover pattern.\n\nexport interface NetworkGraphNodeInfoProps\n  extends React.ComponentProps<\"div\"> {\n  node: NetworkGraphNode\n  connectionCount: number\n}\n\nfunction NetworkGraphNodeInfo({ node, connectionCount, className, ...props }: NetworkGraphNodeInfoProps) {\n  return (\n    <div\n      data-slot=\"network-graph-node-info\"\n      role=\"status\"\n      aria-live=\"polite\"\n      className={cn(\n        \"absolute bottom-3 left-1/2 -translate-x-1/2\",\n        \"flex items-center gap-1.5\",\n        \"rounded-md border bg-card px-2.5 py-1\",\n        \"text-xs text-muted-foreground shadow-sm\",\n        \"pointer-events-none whitespace-nowrap\",\n        className\n      )}\n      {...props}\n    >\n      <span className=\"text-xs font-medium text-card-foreground\">\n        {node.label}\n      </span>\n      {node.subtitle && (\n        <>\n          <span className=\"h-3 w-px bg-border\" aria-hidden=\"true\" />\n          <span>{node.subtitle}</span>\n        </>\n      )}\n      <span className=\"h-3 w-px bg-border\" aria-hidden=\"true\" />\n      <span>\n        {connectionCount} connection{connectionCount !== 1 ? \"s\" : \"\"}\n      </span>\n    </div>\n  )\n}\n\n// ─── NetworkGraphSearch ────────────────────────────────────────────────────────\n\nexport interface NetworkGraphSearchProps\n  extends React.ComponentProps<\"div\"> {\n  query: string\n  onQueryChange: (q: string) => void\n}\n\nfunction NetworkGraphSearch({ query, onQueryChange, className, ...props }: NetworkGraphSearchProps) {\n  return (\n    <div\n      data-slot=\"network-graph-search\"\n      className={cn(\"absolute top-3 left-3 w-48\", className)}\n      {...props}\n    >\n      <input\n        value={query}\n        onChange={(e) => onQueryChange(e.target.value)}\n        placeholder=\"Search nodes…\"\n        className={cn(\n          \"flex h-7 w-full rounded-md border border-input bg-background px-2 py-1\",\n          \"text-xs ring-offset-background\",\n          \"placeholder:text-muted-foreground\",\n          \"focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2\"\n        )}\n        aria-label=\"Search nodes\"\n      />\n    </div>\n  )\n}\n\n// ─── NetworkGraphMinimap ──────────────────────────────────────────────────────\n\nconst MINIMAP_W = 160\nconst MINIMAP_H = 100\n\nexport interface NetworkGraphMinimapProps\n  extends React.ComponentProps<\"svg\"> {\n  graphNodes: NetworkGraphNode[]\n  positions: Record<string, { x: number; y: number }>\n  tf: { x: number; y: number; scale: number }\n  viewWidth: number\n  viewHeight: number\n  onNavigate?: (tf: { x: number; y: number; scale: number }) => void\n}\n\nfunction NetworkGraphMinimap({ graphNodes, positions, tf, viewWidth, viewHeight, onNavigate, className, ...props }: NetworkGraphMinimapProps) {\n    const pts = graphNodes.map((n) => positions[n.id]).filter(Boolean)\n    if (pts.length === 0) return null\n\n    const pad = 8\n    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity\n    for (const p of pts) {\n      minX = Math.min(minX, p.x)\n      minY = Math.min(minY, p.y)\n      maxX = Math.max(maxX, p.x)\n      maxY = Math.max(maxY, p.y)\n    }\n    const gw = maxX - minX || 1\n    const gh = maxY - minY || 1\n    const mmScale = Math.min(\n      (MINIMAP_W - pad * 2) / gw,\n      (MINIMAP_H - pad * 2) / gh\n    )\n\n    // Viewport rect in minimap coords\n    const vpLeft = (-tf.x / tf.scale - minX) * mmScale + pad\n    const vpTop = (-tf.y / tf.scale - minY) * mmScale + pad\n    const vpW = (viewWidth / tf.scale) * mmScale\n    const vpH = (viewHeight / tf.scale) * mmScale\n\n    const handleClick = (e: React.MouseEvent<SVGSVGElement>) => {\n      if (!onNavigate) return\n      const rect = e.currentTarget.getBoundingClientRect()\n      const ex = e.clientX - rect.left\n      const ey = e.clientY - rect.top\n      const worldX = (ex - pad) / mmScale + minX\n      const worldY = (ey - pad) / mmScale + minY\n      onNavigate({\n        scale: tf.scale,\n        x: viewWidth / 2 - worldX * tf.scale,\n        y: viewHeight / 2 - worldY * tf.scale,\n      })\n    }\n\n    return (\n      <svg\n        data-slot=\"network-graph-minimap\"\n        width={MINIMAP_W}\n        height={MINIMAP_H}\n        className={cn(\n          \"absolute top-3 right-3 cursor-pointer\",\n          \"hidden sm:block rounded border bg-card/80 backdrop-blur-sm\",\n          className\n        )}\n        onClick={handleClick}\n        {...props}\n      >\n        <rect\n          data-slot=\"network-graph-minimap-bg\"\n          width={MINIMAP_W}\n          height={MINIMAP_H}\n          className=\"fill-muted/50\"\n          rx={4}\n        />\n        {graphNodes.map((n) => {\n          const pos = positions[n.id]\n          if (!pos) return null\n          const mx = (pos.x - minX) * mmScale + pad\n          const my = (pos.y - minY) * mmScale + pad\n          return (\n            <rect\n              key={n.id}\n              data-slot=\"network-graph-minimap-node\"\n              x={mx - 3}\n              y={my - 2}\n              width={6}\n              height={4}\n              rx={1}\n              className=\"fill-muted-foreground/70\"\n            />\n          )\n        })}\n        <rect\n          data-slot=\"network-graph-minimap-viewport\"\n          x={vpLeft}\n          y={vpTop}\n          width={vpW}\n          height={vpH}\n          rx={2}\n          className=\"fill-transparent stroke-ring [stroke-width:1.5]\"\n        />\n      </svg>\n    )\n}\n\n// ─── NetworkGraph (root) ───────────────────────────────────────────────────────\n\nexport interface NetworkGraphProps extends React.ComponentProps<\"div\"> {\n  nodes?: NetworkGraphNode[]\n  edges?: NetworkGraphEdge[]\n  width?: number\n  height?: number\n  /** When false, disables all pan, zoom, and node drag interactions. Default: true */\n  interactive?: boolean\n  /** Called when the selected node changes. Receives the node id, or null when deselected. */\n  onSelectionChange?: (id: string | null) => void\n  /** Custom simulation parameters. Merged with defaults. */\n  simulationConfig?: Partial<SimulationConfig>\n  /** Layout algorithm. Default: \"force\" */\n  layout?: \"force\" | \"tree\" | \"radial\"\n  /** Show a search/filter input. Default: false */\n  searchable?: boolean\n  /** Show a minimap overview. Default: false */\n  minimap?: boolean\n  /** Show export PNG/SVG buttons. Default: false */\n  exportable?: boolean\n}\n\nfunction NetworkGraph({\n  nodes = [],\n  edges = [],\n  width = 800,\n  height = 500,\n  interactive = true,\n  onSelectionChange,\n  simulationConfig,\n  layout = \"force\",\n  searchable = false,\n  minimap: showMinimap = false,\n  exportable = false,\n  className,\n  ...props\n}: NetworkGraphProps) {\n    const [positions, setPositions] = React.useState<\n      Record<string, { x: number; y: number }>\n    >({})\n    const [tf, setTf] = React.useState({ x: 0, y: 0, scale: 1 })\n    const [selected, setSelected] = React.useState<string | null>(null)\n    const [simDone, setSimDone] = React.useState(false)\n    const [searchQuery, setSearchQuery] = React.useState(\"\")\n\n    const svgRef = React.useRef<SVGSVGElement>(null)\n    const dragRef = React.useRef<{ id: string; sx: number; sy: number } | null>(\n      null\n    )\n    const panRef = React.useRef<{\n      sx: number\n      sy: number\n      ox: number\n      oy: number\n    } | null>(null)\n\n    // Keep a ref to the latest tf so pointer handlers never read stale closures\n    const tfRef = React.useRef(tf)\n    tfRef.current = tf\n\n    // Track active global listeners for cleanup on unmount\n    const cleanupFnsRef = React.useRef<Set<() => void>>(new Set())\n    React.useEffect(() => {\n      return () => {\n        // Clean up any lingering global listeners on unmount\n        for (const fn of cleanupFnsRef.current) fn()\n        cleanupFnsRef.current.clear()\n      }\n    }, [])\n\n    // ── Selection helper — keeps internal state + fires callback ─────────────\n    const select = React.useCallback(\n      (id: string | null) => {\n        setSelected(id)\n        onSelectionChange?.(id)\n      },\n      [onSelectionChange]\n    )\n\n    // ── Fit-to-content ─────────────────────────────────────────────────────\n    const fit = React.useCallback(() => {\n      const pts = Object.values(positions)\n      if (!pts.length) return setTf({ x: 0, y: 0, scale: 1 })\n      const pad = 40\n      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity\n      for (const p of pts) {\n        minX = Math.min(minX, p.x - NODE_W / 2)\n        minY = Math.min(minY, p.y - NODE_H / 2)\n        maxX = Math.max(maxX, p.x + NODE_W / 2)\n        maxY = Math.max(maxY, p.y + NODE_H / 2)\n      }\n      const bw = maxX - minX + pad * 2\n      const bh = maxY - minY + pad * 2\n      const s = Math.max(0.2, Math.min(2, Math.min(width / bw, height / bh)))\n      setTf({\n        scale: s,\n        x: (width - (minX + maxX) * s) / 2,\n        y: (height - (minY + maxY) * s) / 2,\n      })\n    }, [positions, width, height])\n\n    // ── Layout / Force simulation ────────────────────────────────────────────\n    const hasFitted = React.useRef(false)\n    React.useEffect(() => {\n      if (!nodes.length) return\n      setSimDone(false)\n      hasFitted.current = false\n\n      // Static layouts — skip force simulation entirely\n      if (layout === \"tree\" || layout === \"radial\") {\n        const fn = layout === \"tree\" ? computeTreeLayout : computeRadialLayout\n        const pos = fn(nodes, edges, width, height)\n        setPositions(pos)\n        setSimDone(true)\n        return\n      }\n\n      // Force-directed layout (default)\n      const toMap = (pos: SimNode[]) => {\n        const m: Record<string, { x: number; y: number }> = {}\n        nodes.forEach((n, i) => (m[n.id] = { x: pos[i].x, y: pos[i].y }))\n        return m\n      }\n\n      return runSimulation(\n        nodes,\n        edges,\n        width,\n        height,\n        (pos) => setPositions(toMap(pos)),\n        (pos) => {\n          setPositions(toMap(pos))\n          setSimDone(true)\n        },\n        simulationConfig\n      )\n    }, [nodes, edges, width, height, simulationConfig, layout])\n\n    // ── Auto-fit once simulation settles ──────────────────────────────────────\n    React.useEffect(() => {\n      if (!simDone || hasFitted.current) return\n      hasFitted.current = true\n      requestAnimationFrame(() => fit())\n    }, [simDone, fit])\n\n    // ── Node drag ────────────────────────────────────────────────────────────\n    const onNodePointerDown = React.useCallback(\n      (e: React.PointerEvent<SVGGElement>, id: string) => {\n        if (!interactive || e.button !== 0) return\n        try {\n          ;(e.target as Element).setPointerCapture?.(e.pointerId)\n        } catch {\n          // Pointer may already be released on mobile — safe to ignore\n        }\n        dragRef.current = { id, sx: e.clientX, sy: e.clientY }\n\n        const onMove = (ev: PointerEvent) => {\n          if (!dragRef.current) return\n          const dx = (ev.clientX - dragRef.current.sx) / tfRef.current.scale\n          const dy = (ev.clientY - dragRef.current.sy) / tfRef.current.scale\n          dragRef.current.sx = ev.clientX\n          dragRef.current.sy = ev.clientY\n          setPositions((p) => ({\n            ...p,\n            [id]: { x: p[id].x + dx, y: p[id].y + dy },\n          }))\n        }\n\n        const cleanup = () => {\n          dragRef.current = null\n          window.removeEventListener(\"pointermove\", onMove)\n          window.removeEventListener(\"pointerup\", cleanup)\n          window.removeEventListener(\"pointercancel\", cleanup)\n          cleanupFnsRef.current.delete(cleanup)\n        }\n\n        window.addEventListener(\"pointermove\", onMove)\n        window.addEventListener(\"pointerup\", cleanup)\n        window.addEventListener(\"pointercancel\", cleanup)\n        cleanupFnsRef.current.add(cleanup)\n      },\n      [interactive]\n    )\n\n    // ── Canvas pan + pinch-zoom ───────────────────────────────────────────────\n    const pointersRef = React.useRef<Map<number, { x: number; y: number }>>(\n      new Map()\n    )\n    const pinchRef = React.useRef<{ dist: number; mx: number; my: number } | null>(\n      null\n    )\n\n    const onSvgPointerDown = React.useCallback(\n      (e: React.PointerEvent<SVGSVGElement>) => {\n        if (!interactive || e.button !== 0) return\n        pointersRef.current.set(e.pointerId, { x: e.clientX, y: e.clientY })\n\n        // If two fingers, start pinch tracking\n        if (pointersRef.current.size === 2) {\n          const [a, b] = [...pointersRef.current.values()]\n          const dist = Math.hypot(b.x - a.x, b.y - a.y)\n          pinchRef.current = { dist: dist || 1, mx: (a.x + b.x) / 2, my: (a.y + b.y) / 2 }\n          panRef.current = null // cancel any active pan\n          return\n        }\n\n        const t = tfRef.current\n        panRef.current = { sx: e.clientX, sy: e.clientY, ox: t.x, oy: t.y }\n\n        const onMove = (ev: PointerEvent) => {\n          pointersRef.current.set(ev.pointerId, { x: ev.clientX, y: ev.clientY })\n\n          // Pinch-zoom with two pointers\n          if (pointersRef.current.size >= 2 && pinchRef.current) {\n            const pts = [...pointersRef.current.values()]\n            const newDist = Math.hypot(pts[1].x - pts[0].x, pts[1].y - pts[0].y)\n            const factor = pinchRef.current.dist > 0 ? newDist / pinchRef.current.dist : 1\n            const el = svgRef.current\n            if (!el) return\n            const rect = el.getBoundingClientRect()\n            const mx = (pts[0].x + pts[1].x) / 2 - rect.left\n            const my = (pts[0].y + pts[1].y) / 2 - rect.top\n            setTf((prev) => {\n              const ns = Math.max(0.2, Math.min(3, prev.scale * factor))\n              return {\n                scale: ns,\n                x: mx - (mx - prev.x) * (ns / prev.scale),\n                y: my - (my - prev.y) * (ns / prev.scale),\n              }\n            })\n            pinchRef.current.dist = newDist || 1\n            return\n          }\n\n          // Single-pointer pan — capture locally so the ref can't go null\n          // between the guard and when React executes the updater callback.\n          const pan = panRef.current\n          if (!pan) return\n          setTf((prev) => ({\n            ...prev,\n            x: pan.ox + ev.clientX - pan.sx,\n            y: pan.oy + ev.clientY - pan.sy,\n          }))\n        }\n\n        const onUp = (ev: PointerEvent) => {\n          pointersRef.current.delete(ev.pointerId)\n          if (pointersRef.current.size < 2) pinchRef.current = null\n          if (pointersRef.current.size === 0) {\n            panRef.current = null\n            window.removeEventListener(\"pointermove\", onMove)\n            window.removeEventListener(\"pointerup\", onUp)\n            window.removeEventListener(\"pointercancel\", onUp)\n            cleanupFnsRef.current.delete(removeAll)\n          }\n        }\n\n        const removeAll = () => {\n          pointersRef.current.clear()\n          pinchRef.current = null\n          panRef.current = null\n          window.removeEventListener(\"pointermove\", onMove)\n          window.removeEventListener(\"pointerup\", onUp)\n          window.removeEventListener(\"pointercancel\", onUp)\n        }\n\n        window.addEventListener(\"pointermove\", onMove)\n        window.addEventListener(\"pointerup\", onUp)\n        window.addEventListener(\"pointercancel\", onUp)\n        cleanupFnsRef.current.add(removeAll)\n      },\n      [interactive]\n    )\n\n    // ── Scroll zoom ──────────────────────────────────────────────────────────\n    React.useEffect(() => {\n      if (!interactive) return\n      const el = svgRef.current\n      if (!el) return\n\n      const onWheel = (e: WheelEvent) => {\n        e.preventDefault()\n        const delta = e.deltaY > 0 ? 0.9 : 1.1\n        setTf((t) => {\n          const ns = Math.max(0.2, Math.min(3, t.scale * delta))\n          const rect = el.getBoundingClientRect()\n          const mx = e.clientX - rect.left\n          const my = e.clientY - rect.top\n          // Zoom toward cursor point (standard zoom-to-point formula)\n          return {\n            scale: ns,\n            x: mx - (mx - t.x) * (ns / t.scale),\n            y: my - (my - t.y) * (ns / t.scale),\n          }\n        })\n      }\n\n      el.addEventListener(\"wheel\", onWheel, { passive: false })\n      return () => el.removeEventListener(\"wheel\", onWheel)\n    }, [interactive])\n\n    const zoomBy = React.useCallback(\n      (factor: number) =>\n        setTf((t) => {\n          const ns = Math.max(0.2, Math.min(3, t.scale * factor))\n          const cx = width / 2\n          const cy = height / 2\n          return {\n            scale: ns,\n            x: cx - (cx - t.x) * (ns / t.scale),\n            y: cy - (cy - t.y) * (ns / t.scale),\n          }\n        }),\n      [width, height]\n    )\n\n    // ── Export helpers ─────────────────────────────────────────────────────────\n    const cloneAndInlineSVG = React.useCallback(() => {\n      const el = svgRef.current\n      if (!el) return null\n      const clone = el.cloneNode(true) as SVGSVGElement\n      const allEls = [\n        clone,\n        ...Array.from(clone.querySelectorAll(\"*\")),\n      ] as Element[]\n      for (const child of allEls) {\n        const computed = window.getComputedStyle(child)\n        const s = (child as SVGElement | HTMLElement).style\n        for (const prop of [\n          \"fill\",\n          \"stroke\",\n          \"stroke-width\",\n          \"font-size\",\n          \"font-family\",\n          \"font-weight\",\n          \"opacity\",\n        ]) {\n          const val = computed.getPropertyValue(prop)\n          if (val) s.setProperty(prop, val)\n        }\n      }\n      clone\n        .querySelectorAll(\".ng-animated-edge\")\n        .forEach((el) => el.classList.remove(\"ng-animated-edge\"))\n      return clone\n    }, [])\n\n    const exportSVG = React.useCallback(() => {\n      const clone = cloneAndInlineSVG()\n      if (!clone) return\n      const xml = new XMLSerializer().serializeToString(clone)\n      const blob = new Blob([xml], { type: \"image/svg+xml\" })\n      const url = URL.createObjectURL(blob)\n      const a = document.createElement(\"a\")\n      a.href = url\n      a.download = \"network-graph.svg\"\n      a.click()\n      URL.revokeObjectURL(url)\n    }, [cloneAndInlineSVG])\n\n    const exportPNG = React.useCallback(() => {\n      const clone = cloneAndInlineSVG()\n      if (!clone) return\n      const xml = new XMLSerializer().serializeToString(clone)\n      const blob = new Blob([xml], { type: \"image/svg+xml\" })\n      const url = URL.createObjectURL(blob)\n      const img = new Image()\n      img.onload = () => {\n        const canvas = document.createElement(\"canvas\")\n        canvas.width = width * 2\n        canvas.height = height * 2\n        const ctx = canvas.getContext(\"2d\")!\n        ctx.scale(2, 2)\n        ctx.drawImage(img, 0, 0)\n        URL.revokeObjectURL(url)\n        const a = document.createElement(\"a\")\n        a.href = canvas.toDataURL(\"image/png\")\n        a.download = \"network-graph.png\"\n        a.click()\n      }\n      img.src = url\n    }, [cloneAndInlineSVG, width, height])\n\n    // ── Highlighted edges (connected to selected node) ───────────────────────\n    const hiEdgeKeys = React.useMemo<Set<string>>(\n      () =>\n        selected\n          ? new Set(\n              edges\n                .filter(\n                  (e) => e.source === selected || e.target === selected\n                )\n                .map((e) => getEdgeKey(e.source, e.target))\n            )\n          : new Set(),\n      [selected, edges]\n    )\n\n    // ── Group ids for hull rendering ──────────────────────────────────────\n    const groupIds = React.useMemo(\n      () => [...new Set(nodes.flatMap((n) => (n.group ? [n.group] : [])))],\n      [nodes]\n    )\n\n    const selNode = nodes.find((n) => n.id === selected)\n    const connCount = React.useMemo(\n      () =>\n        selected\n          ? edges.filter(\n              (e) => e.source === selected || e.target === selected\n            ).length\n          : 0,\n      [selected, edges]\n    )\n\n    // ── Search filter ───────────────────────────────────────────────────────\n    const matchedIds = React.useMemo<Set<string>>(() => {\n      if (!searchable || !searchQuery.trim())\n        return new Set(nodes.map((n) => n.id))\n      const q = searchQuery.toLowerCase()\n      return new Set(\n        nodes\n          .filter(\n            (n) =>\n              n.label.toLowerCase().includes(q) ||\n              (n.subtitle?.toLowerCase().includes(q) ?? false)\n          )\n          .map((n) => n.id)\n      )\n    }, [searchable, searchQuery, nodes])\n\n    return (\n      <div\n        data-slot=\"network-graph\"\n        data-interactive={interactive || undefined}\n        className={cn(\n          // Matches shadcn Card shell\n          \"relative overflow-hidden rounded-lg border bg-background\",\n          \"select-none touch-none\",\n          className\n        )}\n        style={{ width, height }}\n        {...props}\n      >\n        <svg\n          ref={svgRef}\n          width={width}\n          height={height}\n          onPointerDown={onSvgPointerDown}\n          onClick={() => select(null)}\n          className=\"block touch-none\"\n          aria-label=\"Network graph\"\n          role=\"img\"\n        >\n          <defs>\n            {/*\n             * Two arrowhead markers — one per highlight state.\n             *\n             * Why two markers instead of one with dynamic fill?\n             * SVG <marker> content is painted in a separate context where\n             * CSS custom properties (hsl(var(--...))) are not reliably\n             * resolved at paint time across all browsers.\n             *\n             * Solution: classed <path> inside each marker, styled by\n             * Tailwind's fill-* utilities which compile to concrete values.\n             */}\n            <marker\n              id=\"ng-arrow\"\n              markerWidth={6}\n              markerHeight={6}\n              refX={5}\n              refY={3}\n              orient=\"auto\"\n            >\n              <path d=\"M0,0 L0,6 L6,3 z\" className=\"fill-border\" />\n            </marker>\n            <marker\n              id=\"ng-arrow-hi\"\n              markerWidth={6}\n              markerHeight={6}\n              refX={5}\n              refY={3}\n              orient=\"auto\"\n            >\n              <path\n                d=\"M0,0 L0,6 L6,3 z\"\n                className=\"fill-muted-foreground\"\n              />\n            </marker>\n          </defs>\n\n          <g\n            transform={`translate(${tf.x},${tf.y}) scale(${tf.scale})`}\n          >\n            {/* Group hulls — rendered behind everything else */}\n            {groupIds.length > 0 && (\n              <g aria-hidden=\"true\">\n                {groupIds.map((gid) => (\n                  <NetworkGraphGroup\n                    key={gid}\n                    groupId={gid}\n                    nodes={nodes.filter((n) => n.group === gid)}\n                    positions={positions}\n                  />\n                ))}\n              </g>\n            )}\n\n            {/* Edges — rendered behind nodes, decorative for a11y */}\n            <g aria-hidden=\"true\">\n              {edges.map((e) => {\n                const edgeMatch =\n                  matchedIds.has(e.source) || matchedIds.has(e.target)\n                return (\n                  <NetworkGraphEdgeLine\n                    key={getEdgeKey(e.source, e.target)}\n                    edge={e}\n                    positions={positions}\n                    highlighted={hiEdgeKeys.has(\n                      getEdgeKey(e.source, e.target)\n                    )}\n                    style={{ opacity: edgeMatch ? undefined : 0.15 }}\n                  />\n                )\n              })}\n            </g>\n\n            {/* Edge labels — rendered above edge lines, below nodes */}\n            <g aria-hidden=\"true\">\n              {edges.map((e) => {\n                if (!e.label) return null\n                const s = positions[e.source]\n                const t = positions[e.target]\n                if (!s || !t) return null\n                const nodeBounds = { width: NODE_W, height: NODE_H }\n                const exit = getNodeExitPoint(s, t, nodeBounds)\n                const entry = getNodeExitPoint(t, s, nodeBounds)\n                const mx = (exit.x + entry.x) / 2\n                const my = (exit.y + entry.y) / 2\n                const key = getEdgeKey(e.source, e.target)\n                return (\n                  <NetworkGraphEdgeLabel\n                    key={`label-${key}`}\n                    label={e.label}\n                    x={mx}\n                    y={my}\n                    highlighted={hiEdgeKeys.has(key)}\n                  />\n                )\n              })}\n            </g>\n\n            {/* Nodes — fade in once simulation settles */}\n            <g\n              style={{\n                opacity: simDone ? 1 : 0.5,\n                transition: \"opacity 350ms ease\",\n              }}\n            >\n              {nodes.map((node) => {\n                if (!positions[node.id]) return null\n                const nodeMatch = matchedIds.has(node.id)\n                return (\n                  <NetworkGraphNodeCard\n                    key={node.id}\n                    node={node}\n                    position={positions[node.id]}\n                    selected={selected === node.id}\n                    interactive={interactive && nodeMatch}\n                    onNodePointerDown={onNodePointerDown}\n                    onNodeSelect={select}\n                    style={\n                      nodeMatch\n                        ? undefined\n                        : { opacity: 0.15, pointerEvents: \"none\" as const }\n                    }\n                  />\n                )\n              })}\n            </g>\n          </g>\n        </svg>\n\n        {/* Search input */}\n        {searchable && (\n          <NetworkGraphSearch\n            query={searchQuery}\n            onQueryChange={setSearchQuery}\n          />\n        )}\n\n        {/* Minimap */}\n        {showMinimap && (\n          <NetworkGraphMinimap\n            graphNodes={nodes}\n            positions={positions}\n            tf={tf}\n            viewWidth={width}\n            viewHeight={height}\n            onNavigate={interactive ? setTf : undefined}\n          />\n        )}\n\n        {/* Zoom controls — only shown when interactive */}\n        {interactive && (\n          <NetworkGraphControls\n            onZoomIn={() => zoomBy(1.2)}\n            onZoomOut={() => zoomBy(0.8)}\n            onFit={fit}\n            onExportSVG={exportable ? exportSVG : undefined}\n            onExportPNG={exportable ? exportPNG : undefined}\n          />\n        )}\n\n        {/* Selected node info tooltip */}\n        {selNode && (\n          <NetworkGraphNodeInfo node={selNode} connectionCount={connCount} />\n        )}\n      </div>\n    )\n}\n\n// ─── Exports ───────────────────────────────────────────────────────────────────\n// Named exports for every composable piece (same pattern as card.tsx, dialog.tsx)\n\nexport {\n  NetworkGraph,\n  NetworkGraphNodeCard,\n  NetworkGraphEdgeLine,\n  NetworkGraphEdgeLabel,\n  NetworkGraphGroup,\n  NetworkGraphSearch,\n  NetworkGraphMinimap,\n  NetworkGraphControls,\n  NetworkGraphNodeInfo,\n}\n",
      "type": "registry:ui",
      "target": "components/ui/network-graph.tsx"
    },
    {
      "path": "registry/ui/simulation.ts",
      "content": "/**\n * simulation.ts\n * Force-directed layout engine — no external dependencies.\n * Designed to run entirely outside React state (mutates internal pos[] array,\n * commits to React only on batched ticks).\n */\n\nexport interface SimNode {\n  x: number\n  y: number\n  vx: number\n  vy: number\n}\n\nexport interface SimEdge {\n  source: string\n  target: string\n}\n\nexport interface SimGraphNode {\n  id: string\n  /** Pre-set initial x position. If omitted, randomized. */\n  x?: number\n  /** Pre-set initial y position. If omitted, randomized. */\n  y?: number\n  /** When true, simulation will not move this node. Default: false */\n  fixed?: boolean\n}\n\n// ─── Simulation config ───────────────────────────────────────────────────────\n\nexport interface SimulationConfig {\n  /** Number of simulation iterations. Default: 300 */\n  iterations: number\n  /** Repulsion multiplier on k² (ideal spring length squared). Default: 0.5 */\n  repulsion: number\n  /** Edge spring constant. Default: 0.08 */\n  attraction: number\n  /** Pull toward canvas center. Default: 0.08 */\n  gravity: number\n  /** Velocity damping per tick. Default: 0.7 */\n  damping: number\n  /** Euler integration step. Default: 0.85 */\n  integration: number\n  /** Commit to React every N frames. Default: 8 */\n  tickInterval: number\n  /** Node count above which Barnes-Hut is used. Default: 100 */\n  barnesHutThreshold: number\n  /** Barnes-Hut accuracy (0–1, lower = more accurate). Default: 0.7 */\n  barnesHutTheta: number\n}\n\nexport const DEFAULT_SIMULATION_CONFIG: SimulationConfig = {\n  iterations: 300,\n  repulsion: 0.5,\n  attraction: 0.08,\n  gravity: 0.08,\n  damping: 0.7,\n  integration: 0.85,\n  tickInterval: 8,\n  barnesHutThreshold: 100,\n  barnesHutTheta: 0.7,\n}\n\n// ─── Barnes-Hut quadtree ─────────────────────────────────────────────────────\n\ninterface QTNode {\n  // Bounding box\n  x0: number\n  y0: number\n  x1: number\n  y1: number\n  // Center of mass\n  cx: number\n  cy: number\n  mass: number\n  // Leaf body index (or -1 if internal)\n  body: number\n  // Children: NW, NE, SW, SE (null if empty)\n  children: (QTNode | null)[] | null\n}\n\nfunction createQTNode(x0: number, y0: number, x1: number, y1: number): QTNode {\n  return { x0, y0, x1, y1, cx: 0, cy: 0, mass: 0, body: -1, children: null }\n}\n\nfunction qtInsert(node: QTNode, idx: number, x: number, y: number): void {\n  const midX = (node.x0 + node.x1) / 2\n  const midY = (node.y0 + node.y1) / 2\n\n  if (node.mass === 0) {\n    // Empty node — place body here\n    node.body = idx\n    node.cx = x\n    node.cy = y\n    node.mass = 1\n    return\n  }\n\n  // If leaf, subdivide and re-insert existing body\n  if (node.children === null) {\n    node.children = [null, null, null, null]\n    const oldIdx = node.body\n    const oldX = node.cx\n    const oldY = node.cy\n    node.body = -1\n    qtInsert(node, oldIdx, oldX, oldY)\n  }\n\n  // Insert new body into the correct quadrant\n  const quadrant =\n    (x > midX ? 1 : 0) + (y > midY ? 2 : 0)\n\n  if (node.children![quadrant] === null) {\n    const qx0 = quadrant & 1 ? midX : node.x0\n    const qy0 = quadrant & 2 ? midY : node.y0\n    const qx1 = quadrant & 1 ? node.x1 : midX\n    const qy1 = quadrant & 2 ? node.y1 : midY\n    node.children![quadrant] = createQTNode(qx0, qy0, qx1, qy1)\n  }\n\n  qtInsert(node.children![quadrant]!, idx, x, y)\n\n  // Update center of mass\n  const totalMass = node.mass + 1\n  node.cx = (node.cx * node.mass + x) / totalMass\n  node.cy = (node.cy * node.mass + y) / totalMass\n  node.mass = totalMass\n}\n\nfunction applyRepulsionBarnesHut(\n  pos: SimNode[],\n  repulsion: number,\n  alpha: number,\n  theta: number\n): void {\n  // Compute bounds\n  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity\n  for (const p of pos) {\n    if (p.x < minX) minX = p.x\n    if (p.y < minY) minY = p.y\n    if (p.x > maxX) maxX = p.x\n    if (p.y > maxY) maxY = p.y\n  }\n  const pad = 1\n  const root = createQTNode(minX - pad, minY - pad, maxX + pad, maxY + pad)\n\n  // Build tree\n  for (let i = 0; i < pos.length; i++) {\n    qtInsert(root, i, pos[i].x, pos[i].y)\n  }\n\n  // Traverse tree for each body\n  for (let i = 0; i < pos.length; i++) {\n    applyForceFromNode(pos, i, root, repulsion, alpha, theta)\n  }\n}\n\nfunction applyForceFromNode(\n  pos: SimNode[],\n  i: number,\n  node: QTNode,\n  repulsion: number,\n  alpha: number,\n  theta: number\n): void {\n  if (node.mass === 0) return\n\n  const dx = node.cx - pos[i].x || 0.01\n  const dy = node.cy - pos[i].y || 0.01\n  const dist2 = dx * dx + dy * dy || 1\n\n  // Leaf with single body — direct calculation\n  if (node.body >= 0) {\n    if (node.body !== i) {\n      const force = (repulsion / dist2) * alpha\n      pos[i].vx -= dx * force\n      pos[i].vy -= dy * force\n    }\n    return\n  }\n\n  // Check if cell is far enough to approximate\n  const size = node.x1 - node.x0\n  if (size * size / dist2 < theta * theta) {\n    const force = (repulsion * node.mass / dist2) * alpha\n    pos[i].vx -= dx * force\n    pos[i].vy -= dy * force\n    return\n  }\n\n  // Recurse into children\n  if (node.children) {\n    for (const child of node.children) {\n      if (child) applyForceFromNode(pos, i, child, repulsion, alpha, theta)\n    }\n  }\n}\n\nfunction applyRepulsionBruteForce(\n  pos: SimNode[],\n  repulsion: number,\n  alpha: number\n): void {\n  for (let i = 0; i < pos.length; i++) {\n    for (let j = i + 1; j < pos.length; j++) {\n      const dx = pos[j].x - pos[i].x || 0.01\n      const dy = pos[j].y - pos[i].y || 0.01\n      const dist2 = dx * dx + dy * dy || 1\n      const force = (repulsion / dist2) * alpha\n      pos[i].vx -= dx * force\n      pos[i].vy -= dy * force\n      pos[j].vx += dx * force\n      pos[j].vy += dy * force\n    }\n  }\n}\n\n// ─── Main simulation ─────────────────────────────────────────────────────────\n\nexport function runSimulation(\n  nodes: SimGraphNode[],\n  edges: SimEdge[],\n  width: number,\n  height: number,\n  onTick: (positions: SimNode[]) => void,\n  onEnd: (positions: SimNode[]) => void,\n  config?: Partial<SimulationConfig>\n): () => void {\n  const cfg = { ...DEFAULT_SIMULATION_CONFIG, ...config }\n  const k = Math.sqrt((width * height) / Math.max(nodes.length, 1))\n  const repulsion = k * k * cfg.repulsion\n  const cx = width / 2\n  const cy = height / 2\n  const useBarnesHut = nodes.length > cfg.barnesHutThreshold\n\n  // Initialise: use provided positions or scatter randomly around center\n  const pos: SimNode[] = nodes.map((n) => ({\n    x: n.x ?? cx + (Math.random() - 0.5) * width * 0.5,\n    y: n.y ?? cy + (Math.random() - 0.5) * height * 0.5,\n    vx: 0,\n    vy: 0,\n  }))\n\n  // Index: node id → position array index\n  const idx: Record<string, number> = {}\n  nodes.forEach((n, i) => (idx[n.id] = i))\n\n  let frame = 0\n  let animId: number\n\n  function step() {\n    const alpha = Math.max(0, 1 - frame / cfg.iterations)\n\n    if (alpha <= 0) {\n      onTick([...pos])\n      onEnd([...pos])\n      return\n    }\n\n    // Repulsion: choose algorithm based on node count\n    if (useBarnesHut) {\n      applyRepulsionBarnesHut(pos, repulsion, alpha, cfg.barnesHutTheta)\n    } else {\n      applyRepulsionBruteForce(pos, repulsion, alpha)\n    }\n\n    // Attraction: edges act as springs pulling connected nodes together\n    for (const e of edges) {\n      const s = pos[idx[e.source]]\n      const t = pos[idx[e.target]]\n      if (!s || !t) continue\n      const dx = t.x - s.x\n      const dy = t.y - s.y\n      const dist = Math.sqrt(dx * dx + dy * dy) || 1\n      const force = (dist - k) * cfg.attraction * alpha\n      const fx = (dx / dist) * force\n      const fy = (dy / dist) * force\n      s.vx += fx\n      s.vy += fy\n      t.vx -= fx\n      t.vy -= fy\n    }\n\n    // Gravity + integration + damping + fixed-node handling\n    for (let i = 0; i < pos.length; i++) {\n      const p = pos[i]\n      const n = nodes[i]\n\n      if (n.fixed) {\n        // Fixed nodes: restore initial position, zero velocity\n        p.x = n.x ?? p.x\n        p.y = n.y ?? p.y\n        p.vx = 0\n        p.vy = 0\n        continue\n      }\n\n      p.vx += (cx - p.x) * cfg.gravity * alpha\n      p.vy += (cy - p.y) * cfg.gravity * alpha\n      p.x += p.vx * cfg.integration\n      p.y += p.vy * cfg.integration\n      p.vx *= cfg.damping\n      p.vy *= cfg.damping\n    }\n\n    frame++\n    // Batch React updates — commit every tickInterval frames\n    if (frame % cfg.tickInterval === 0) {\n      onTick([...pos])\n    }\n\n    animId = requestAnimationFrame(step)\n  }\n\n  animId = requestAnimationFrame(step)\n  return () => cancelAnimationFrame(animId)\n}\n\n// ─── Geometry utilities ────────────────────────────────────────────────────────\n\nexport interface Point {\n  x: number\n  y: number\n}\n\nexport interface NodeBounds {\n  width: number\n  height: number\n}\n\n/**\n * Compute where a line from `source` toward `target` exits the source node's\n * bounding box. Used to start edges at the node border rather than its center.\n */\nexport function getNodeExitPoint(\n  source: Point,\n  target: Point,\n  bounds: NodeBounds\n): Point {\n  const dx = target.x - source.x\n  const dy = target.y - source.y\n  const dist = Math.sqrt(dx * dx + dy * dy) || 1\n  const ux = dx / dist\n  const uy = dy / dist\n\n  const hw = bounds.width / 2\n  const hh = bounds.height / 2\n\n  // Parametric intersection with the node bounding box\n  const tX = Math.abs(ux) > 0 ? hw / Math.abs(ux) : Infinity\n  const tY = Math.abs(uy) > 0 ? hh / Math.abs(uy) : Infinity\n  const t = Math.min(tX, tY)\n\n  return {\n    x: source.x + ux * t,\n    y: source.y + uy * t,\n  }\n}\n\n/**\n * Stable string key for an edge, used for React reconciliation.\n */\nexport function getEdgeKey(source: string, target: string): string {\n  return `${source}→${target}`\n}\n",
      "type": "registry:lib",
      "target": "components/ui/network-graph-simulation.ts"
    },
    {
      "path": "registry/ui/network-graph-layouts.ts",
      "content": "/**\n * network-graph-layouts.ts\n * Static layout algorithms for NetworkGraph.\n * Each function returns Record<string, {x,y}> — same shape as positions state.\n */\n\nexport type LayoutPositions = Record<string, { x: number; y: number }>\n\ninterface LayoutNode {\n  id: string\n}\n\ninterface LayoutEdge {\n  source: string\n  target: string\n}\n\n/**\n * BFS-based tree layout: root at left, layers spread horizontally.\n * Finds root as the node with zero incoming edges (falls back to nodes[0]).\n */\nexport function computeTreeLayout(\n  nodes: LayoutNode[],\n  edges: LayoutEdge[],\n  width: number,\n  height: number\n): LayoutPositions {\n  if (nodes.length === 0) return {}\n\n  const { layers, maxDepth } = buildLayers(nodes, edges)\n  const positions: LayoutPositions = {}\n  const pad = 60\n\n  for (const [depthStr, layerNodes] of Object.entries(layers)) {\n    const depth = Number(depthStr)\n    const x =\n      maxDepth === 0\n        ? width / 2\n        : pad + ((width - pad * 2) * depth) / maxDepth\n    const count = layerNodes.length\n    for (let i = 0; i < count; i++) {\n      const y =\n        count === 1\n          ? height / 2\n          : pad + ((height - pad * 2) * i) / (count - 1)\n      positions[layerNodes[i]] = { x, y }\n    }\n  }\n\n  return positions\n}\n\n/**\n * BFS-based radial layout: root at center, layers on concentric rings.\n */\nexport function computeRadialLayout(\n  nodes: LayoutNode[],\n  edges: LayoutEdge[],\n  width: number,\n  height: number\n): LayoutPositions {\n  if (nodes.length === 0) return {}\n\n  const { layers, maxDepth } = buildLayers(nodes, edges)\n  const positions: LayoutPositions = {}\n  const cx = width / 2\n  const cy = height / 2\n  const maxRadius = Math.min(width, height) / 2 - 80\n\n  for (const [depthStr, layerNodes] of Object.entries(layers)) {\n    const depth = Number(depthStr)\n\n    if (depth === 0) {\n      // Root at center\n      for (const id of layerNodes) {\n        positions[id] = { x: cx, y: cy }\n      }\n      continue\n    }\n\n    const radius =\n      maxDepth === 0 ? 0 : (depth / maxDepth) * maxRadius\n    const count = layerNodes.length\n    for (let i = 0; i < count; i++) {\n      const angle = (2 * Math.PI * i) / count - Math.PI / 2\n      positions[layerNodes[i]] = {\n        x: cx + radius * Math.cos(angle),\n        y: cy + radius * Math.sin(angle),\n      }\n    }\n  }\n\n  return positions\n}\n\n// ─── Internal helpers ─────────────────────────────────────────────────────────\n\nfunction buildLayers(\n  nodes: LayoutNode[],\n  edges: LayoutEdge[]\n): { layers: Record<number, string[]>; maxDepth: number } {\n  // Build adjacency and compute incoming edge count\n  const children = new Map<string, string[]>()\n  const incoming = new Map<string, number>()\n  for (const n of nodes) {\n    children.set(n.id, [])\n    incoming.set(n.id, 0)\n  }\n  for (const e of edges) {\n    children.get(e.source)?.push(e.target)\n    incoming.set(e.target, (incoming.get(e.target) ?? 0) + 1)\n  }\n\n  // Find root: node with zero incoming edges. Fallback: nodes[0].\n  const roots = nodes.filter((n) => (incoming.get(n.id) ?? 0) === 0)\n  const root = roots.length > 0 ? roots[0].id : nodes[0].id\n\n  // BFS to assign depths\n  const depth = new Map<string, number>()\n  const queue: string[] = [root]\n  depth.set(root, 0)\n\n  while (queue.length > 0) {\n    const id = queue.shift()!\n    const d = depth.get(id)!\n    for (const child of children.get(id) ?? []) {\n      if (!depth.has(child)) {\n        depth.set(child, d + 1)\n        queue.push(child)\n      }\n    }\n  }\n\n  // Any unreachable nodes get placed at max depth + 1\n  let maxDepth = 0\n  for (const d of depth.values()) {\n    if (d > maxDepth) maxDepth = d\n  }\n  for (const n of nodes) {\n    if (!depth.has(n.id)) {\n      depth.set(n.id, maxDepth + 1)\n    }\n  }\n  // Recalculate maxDepth\n  maxDepth = 0\n  for (const d of depth.values()) {\n    if (d > maxDepth) maxDepth = d\n  }\n\n  // Group by layer\n  const layers: Record<number, string[]> = {}\n  for (const n of nodes) {\n    const d = depth.get(n.id)!\n    if (!layers[d]) layers[d] = []\n    layers[d].push(n.id)\n  }\n\n  return { layers, maxDepth }\n}\n",
      "type": "registry:lib",
      "target": "components/ui/network-graph-layouts.ts"
    }
  ],
  "type": "registry:ui"
}